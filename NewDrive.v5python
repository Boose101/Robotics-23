{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nleft_motor_a = Motor(Ports.PORT1, GearSetting.RATIO_18_1, False)\nleft_motor_b = Motor(Ports.PORT2, GearSetting.RATIO_18_1, False)\nleft_drive_smart = MotorGroup(left_motor_a, left_motor_b)\nright_motor_a = Motor(Ports.PORT3, GearSetting.RATIO_18_1, True)\nright_motor_b = Motor(Ports.PORT4, GearSetting.RATIO_18_1, True)\nright_drive_smart = MotorGroup(right_motor_a, right_motor_b)\ndrivetrain = DriveTrain(left_drive_smart, right_drive_smart, 319.19, 295, 40, MM, 1)\ncontroller_1 = Controller(PRIMARY)\nmotor_5 = Motor(Ports.PORT5, GearSetting.RATIO_18_1, False)\nmotor_6 = Motor(Ports.PORT6, GearSetting.RATIO_18_1, False)\nmotor_group_7_motor_a = Motor(Ports.PORT7, GearSetting.RATIO_18_1, False)\nmotor_group_7_motor_b = Motor(Ports.PORT8, GearSetting.RATIO_18_1, False)\narm_motor_group = MotorGroup(motor_group_7_motor_a, motor_group_7_motor_b)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\n\n#AUTON init\n\n#AUTON Settings\nrecordInput = True\nauton = False\n\nautonomous_start_offset = 0\n\n#Paste recorded input here:\nRECORDED_INPUT = \"100:100:300\"\n\n##############\n\nclass DriveType:\n    LEFT = 0\n    DUAL = 1\n    SPLIT = 2\n    RIGHT = 3\n    value = 0\n\n    def __init__(self, value):\n        self.value = value\n    def __str__(self):\n        return self.value\n    def __repr__(self):\n        return self.value\n    def __eq__(self, value):\n        return self.value == value\n\n# pick LEFT, DUAL, SPLIT or RIGHT\ndrive_mode = DriveType(DriveType.SPLIT)\n\n#Drive code\n\ndef motor_task(drive_left, drive_right):\n    # drive_m_3 = (controller_1.buttonL1.pressing() - controller_1.buttonL2.pressing()) * MAX_SPEED\n    # drive_m_4 = (controller_1.buttonRight.pressing() - controller_1.buttonLeft.pressing()) * MAX_SPEED\n    # drive_m_5 = (controller_1.buttonUp.pressing() - controller_1.buttonDown.pressing()) * MAX_SPEED\n    # drive_m_6 = (controller_1.buttonA.pressing() - controller_1.buttonY.pressing()) * MAX_SPEED\n    # drive_m_7 = (controller_1.buttonX.pressing() - controller_1.buttonB.pressing()) * MAX_SPEED\n    # drive_m_8 = (controller_1.buttonR1.pressing() - controller_1.buttonR2.pressing()) * MAX_SPEED\n\n    #send Val\n\n    # The drivetrain\n    left_motor_a.spin(FORWARD, drive_left, PERCENT)\n    left_motor_b.spin(FORWARD, drive_left, PERCENT)\n    right_motor_a.spin(FORWARD, drive_right, PERCENT)\n    right_motor_b.spin(FORWARD, drive_right, PERCENT)\n\n    # and all the auxilary motors\n    # motor_3.spin(FORWARD, drive_m_3, PERCENT)\n    # motor_4.spin(FORWARD, drive_m_4, PERCENT)\n    # motor_5.spin(FORWARD, drive_m_5, PERCENT)\n    # motor_6.spin(FORWARD, drive_m_6, PERCENT)\n    # motor_7.spin(FORWARD, drive_m_7, PERCENT)\n    # motor_8.spin(FORWARD, drive_m_8, PERCENT)\n\n# Max motor speed (percent) for motors controlled by buttons\nMAX_SPEED = 80\n\n#-----------------------------------------------------------------------------*/\n#   @brief  Drive task                                                        */\n#-----------------------------------------------------------------------------*/\n#\n# All motors are controlled from this function which is run as a separate thread\n#\n\ndrive_left_cur = 0\ndrive_right_cur = 0\n\nbrainPrevStepTime = int(brain.timer.time(MSEC))\nbetweenStepTime = 0\n\n\nwhile True:\n    if(not auton):\n        if drive_mode == DriveType.LEFT:\n            drive_left = int(controller_1.axis3.position()) + int(controller_1.axis4.position())\n            drive_right = int(controller_1.axis3.position()) - int(controller_1.axis4.position())\n        elif drive_mode == DriveType.DUAL:\n            drive_left = controller_1.axis3.position()\n            drive_right = controller_1.axis2.position()\n        elif drive_mode == DriveType.SPLIT:\n            drive_left = controller_1.axis3.position() + controller_1.axis1.position()\n            drive_right = controller_1.axis3.position() - controller_1.axis1.position()\n        elif drive_mode == DriveType.RIGHT:\n            drive_left = controller_1.axis2.position() + controller_1.axis1.position()\n            drive_right = controller_1.axis2.position() - controller_1.axis1.position()\n\n        ## Deadband allows non 0 ret to not move robbot\n        deadband = 5\n        if abs(drive_left) < deadband:\n            drive_left = 0\n        if abs(drive_right) < deadband:\n            drive_right = 0\n        \n        if controller_1.buttonR1.pressing():\n            arm_motor_group.spin(FORWARD)\n            controller_1_right_shoulder_control_motors_stopped = False\n        elif controller_1.buttonR2.pressing():\n            arm_motor_group.spin(REVERSE)\n            controller_1_right_shoulder_control_motors_stopped = False\n        elif not controller_1_right_shoulder_control_motors_stopped:\n            arm_motor_group.stop()\n            # set the toggle so that we don't constantly tell the motor to stop when\n            # the buttons are released\n            controller_1_right_shoulder_control_motors_stopped = True\n\n        if(recordInput and (drive_left != drive_left_cur or drive_right != drive_right_cur)):\n            drive_left_cur = drive_left\n            drive_right_cur = drive_right\n\n            ####Auton\n            ##time setup\n            betweenStepTime = int(brain.timer.time(MSEC)) - brainPrevStepTime\n            brainPrevStepTime = int(brain.timer.time(MSEC))\n\n            ##printing\n            # driveWord = drive_left + \":\" + drive_right\n            print(drive_left, drive_right, end=\":\", sep=\":\")\n            print(betweenStepTime)\n\n\n            #drive - drive_left, drive_right\n            motor_task(drive_left, drive_right)\n            \n        \n    else:\n        inputSplit = RECORDED_INPUT.split(\":\")\n        # ranger = range((len(inputSplit)/3)-1)\n        print(len(inputSplit))\n        for num in range(int(len(inputSplit)//3)):\n            print(\"num:\",num)\n\n            d_left = inputSplit[3*num]\n            print(d_left)\n            d_right = inputSplit[3*num + 1]\n            print(d_right)\n            wait_time = int(inputSplit[3*num + 2])\n            print(wait_time)\n\n            wait(wait_time, MSEC)\n\ndef autonomous():\n        inputSplit = RECORDED_INPUT.split(\":\")\n        for num in range(int(len(inputSplit)//3)):\n            d_left = inputSplit[3*num]\n            d_right = inputSplit[3*num + 1]\n            wait_time = inputSplit[3*num + 2]\n            motor_task(d_left, d_right)            \n            wait(wait_time, MSEC)\n\ndef driver_control():\n    controller_1_right_shoulder_control_motors_stopped = True\n    while True:\n        if drive_mode == DriveType.LEFT:\n            drive_left = controller_1.axis3.position() + controller_1.axis4.position()\n            drive_right = controller_1.axis3.position() - controller_1.axis4.position()\n        elif drive_mode == DriveType.DUAL:\n            drive_left = controller_1.axis3.position()\n            drive_right = controller_1.axis2.position()\n        elif drive_mode == DriveType.SPLIT:\n            drive_left = controller_1.axis3.position() + controller_1.axis1.position()\n            drive_right = controller_1.axis3.position() - controller_1.axis1.position()\n        elif drive_mode == DriveType.RIGHT:\n            drive_left = controller_1.axis2.position() + controller_1.axis1.position()\n            drive_right = controller_1.axis2.position() - controller_1.axis1.position()\n\n        if controller_1.buttonR1.pressing():\n            arm_motor_group.spin(FORWARD)\n            controller_1_right_shoulder_control_motors_stopped = False\n        elif controller_1.buttonR2.pressing():\n            arm_motor_group.spin(REVERSE)\n            controller_1_right_shoulder_control_motors_stopped = False\n        elif not controller_1_right_shoulder_control_motors_stopped:\n            arm_motor_group.stop()\n            # set the toggle so that we don't constantly tell the motor to stop when\n            # the buttons are released\n            controller_1_right_shoulder_control_motors_stopped = True\n\n        ## Deadband allows non 0 ret to not move robbot\n        deadband = 5\n        if abs(drive_left) < deadband:\n            drive_left = 0\n        if abs(drive_right) < deadband:\n            drive_right = 0\n\n\n        ## Drive\n        motor_task(drive_left, drive_right)\n\n\n\n\n\n\n\n\n\n# define some more colors\ngrey = Color(0x202020)\ndgrey = Color(0x2F4F4F)\nlblue = Color(0x303060)\nlred = Color(0x603030)\n\n#------------------------------------------------------------------------------*/\n#   @brief      Display data for one motor                                     */\n#------------------------------------------------------------------------------*/\ndef displayMotorData(m, index):\n    ypos = 0\n    xpos = index * 48\n\n    # command value not available in Python\n    v1 = 0\n\n    # The actual velocity of the motor in rpm\n    v2 = m.velocity(RPM)\n\n    # The position of the motor internal encoder in revolutions\n    pos = m.position(TURNS)\n\n    # Motor current in Amps\n    c1 = m.current()\n\n    # Motor temperature\n    t1 = m.temperature()\n\n    brain.screen.set_font(FontType.MONO15)\n\n    # background color based on\n    # device and whether it's left, right or other motor\n    if not m.installed():\n        brain.screen.set_fill_color(grey)\n    elif m == left_motor_a or m == left_motor_b:\n        brain.screen.set_fill_color(lblue)\n    elif m == right_motor_a or m == right_motor_b:\n        brain.screen.set_fill_color(lred)\n    else:\n        brain.screen.set_fill_color(dgrey)\n\n    # Draw outline for motor info\n    brain.screen.set_pen_color(Color.WHITE)\n    w = 49 if index < 9 else 48\n    brain.screen.draw_rectangle(xpos, ypos, w, 79)\n\n    # no motor, then return early\n    if not m.installed():\n        brain.screen.print_at(\"NC\", x=xpos+15, y=ypos+30)\n        return\n\n    # we have no way to get command value in Python VM 1.0.0b20\n    # so have to deviate from C++ version, just show port number\n    brain.screen.print_at(\"%02d\" % (index+1), x=xpos+13, y=ypos+13)\n\n    # Show actual speed\n    brain.screen.set_pen_color(Color.YELLOW)\n    brain.screen.print_at(\"%4d\" % v2, x=xpos+13, y=ypos+30)\n\n    # Show position\n    brain.screen.print_at(\"%5.1f\" % pos, x=xpos+5, y=ypos+45)\n\n    # Show current\n    brain.screen.print_at(\"%4.1fA\" % c1, x=xpos+5, y=ypos+60)\n\n    # Show temperature\n    brain.screen.print_at(\"%4.0fC\" % t1, x=xpos+5, y=ypos+75)\n\n    brain.screen.set_pen_color(Color.WHITE)\n    brain.screen.draw_line(xpos, ypos+14, xpos+48, ypos+14)\n\n\n#-----------------------------------------------------------------------------*/\n#   @brief  Display task - show some useful motor data                        */\n#-----------------------------------------------------------------------------*/\ndef display_task():\n    brain.screen.set_font(FontType.PROP40)\n    brain.screen.set_pen_color(Color.RED)\n    brain.screen.print_at(\"TEST DRIVE CODE\", x=90, y=160)\n\n    # motors = [motor_1,\n    #         #   motor_2,\n    #         #   motor_3,\n    #         #   motor_4,\n    #         #   motor_5,\n    #         #   motor_6,\n    #         #   motor_7,\n    #           motor_8,\n    #           motor_9,\n    #           motor_10]\n\n    # while True:\n    #     index = 0\n    #     for m in motors:\n    #         displayMotorData(m, index)\n    #         index = index+1\n\n    #     # display using back buffer, stops flickering\n    #     brain.screen.render()\n\n    #     sleep(10)\n\n# Run the drive code\ndrive = Thread(motor_task)\n\n# Run the display code\ndisplay = Thread(display_task)","textLanguage":"python","rconfig":[{"port":[1,2,3,4,null],"name":"drivetrain","customName":false,"deviceType":"Drivetrain","deviceClass":"smartdrive","setting":{"type":"4-motor","wheelSize":"wheel4in","gear":"ratio18_1","gearRatio":"1:1","direction":"fwd","gyroType":"none","width":"295","unit":"mm","wheelbase":"40","wheelbaseUnit":"mm","xOffset":"0","xOffsetUnit":"mm","yOffset":"0","yOffsetUnit":"mm","thetaOffset":"180"},"triportSourcePort":null},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[5],"name":"motor_5","customName":false,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[6],"name":"motor_6","customName":false,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"},"triportSourcePort":22},{"port":[7,8],"name":"motor_group_7","customName":false,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","gear":"ratio18_1","motor_a_reversed":"false","motor_b_reversed":"false","id":"partner"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"3.0.4","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}