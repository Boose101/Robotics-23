#region VEXcode Generated Robot Configuration
from vex import *
import urandom

# Brain should be defined by default
brain=Brain()

# Robot configuration code
controller_1 = Controller(PRIMARY)
left_motor_a = Motor(Ports.PORT1, GearSetting.RATIO_18_1, False)
left_motor_b = Motor(Ports.PORT2, GearSetting.RATIO_18_1, False)
left_drive_smart = MotorGroup(left_motor_a, left_motor_b)
right_motor_a = Motor(Ports.PORT3, GearSetting.RATIO_18_1, True)
right_motor_b = Motor(Ports.PORT4, GearSetting.RATIO_18_1, True)
right_drive_smart = MotorGroup(right_motor_a, right_motor_b)
drivetrain = DriveTrain(left_drive_smart, right_drive_smart, 319.19, 295, 40, MM, 1)


# wait for rotation sensor to fully initialize
wait(30, MSEC)


def play_vexcode_sound(sound_name):
    # Helper to make playing sounds from the V5 in VEXcode easier and
    # keeps the code cleaner by making it clear what is happening.
    print("VEXPlaySound:" + sound_name)
    wait(5, MSEC)

# add a small delay to make sure we don't print in the middle of the REPL header
wait(200, MSEC)
# clear the console to make sure we don't have the REPL in the console
print("\033[2J")

#endregion VEXcode Generated Robot Configuration
#region VEXcode Generated Robot Configuration
from vex import *
import urandom

# Brain should be defined by default
brain=Brain()

# Robot configuration code
#This assigns all the variables
left_motor_a = Motor(Ports.PORT2, GearSetting.RATIO_18_1, False)
left_motor_b = Motor(Ports.PORT10, GearSetting.RATIO_18_1, False)
left_drive_smart = MotorGroup(left_motor_a, left_motor_b)
right_motor_a = Motor(Ports.PORT1, GearSetting.RATIO_18_1, True)
right_motor_b = Motor(Ports.PORT9, GearSetting.RATIO_18_1, True)
right_drive_smart = MotorGroup(right_motor_a, right_motor_b)
drivetrain = DriveTrain(left_drive_smart, right_drive_smart, 319.19, 295, 40, MM, 1)
controller_1 = Controller(PRIMARY)
arm_motor_a = Motor(Ports.PORT3, GearSetting.RATIO_36_1, False)
arm_motor_b = Motor(Ports.PORT8, GearSetting.RATIO_18_1, False)
arm_motor_group_motor_a = Motor(Ports.PORT7, GearSetting.RATIO_36_1, False)
arm_motor_group_motor_b = Motor(Ports.PORT4, GearSetting.RATIO_36_1, True)
arm_motor_group = MotorGroup(arm_motor_group_motor_a, arm_motor_group_motor_b)


# wait for rotation sensor to fully initialize
wait(30, MSEC)




# add a small delay to make sure we don't print in the middle of the REPL header
wait(200, MSEC)
# clear the console to make sure we don't have the REPL in the console
print("\033[2J")

#endregion VEXcode Generated Robot Configuration
#AUTON init

#AUTON Settings
recordInput = True
auton = False

autonomous_start_offset = 0

#Paste recorded input here:
DRIVE_RECORDED_INPUT = "100:100:300"
ARM_RECORDED_INPUT = "True:True:False:174"

##############
#This determines which style of driving is picked
#For example Left makes all the drive controls on the left axis
class DriveType:
    LEFT = 0
    DUAL = 1
    SPLIT = 2
    RIGHT = 3
    value = 0

    def __init__(self, value):
        self.value = value
    def __str__(self):
        return self.value
    def __repr__(self):
        return self.value
    def __eq__(self, value):
        return self.value == value

# pick LEFT, DUAL, SPLIT or RIGHT
drive_mode = DriveType(DriveType.SPLIT)

#Drive code
#This makes the motars that drive spin
def motor_task(drive_left, drive_right):
    # drive_m_3 = (controller_1.buttonL1.pressing() - controller_1.buttonL2.pressing()) * MAX_SPEED
    # drive_m_4 = (controller_1.buttonRight.pressing() - controller_1.buttonLeft.pressing()) * MAX_SPEED
    # drive_m_5 = (controller_1.buttonUp.pressing() - controller_1.buttonDown.pressing()) * MAX_SPEED
    # drive_m_6 = (controller_1.buttonA.pressing() - controller_1.buttonY.pressing()) * MAX_SPEED
    # drive_m_7 = (controller_1.buttonX.pressing() - controller_1.buttonB.pressing()) * MAX_SPEED
    # drive_m_8 = (controller_1.buttonR1.pressing() - controller_1.buttonR2.pressing()) * MAX_SPEED

    #send Val

    # The drivetrain
    left_motor_a.spin(FORWARD, drive_left, PERCENT)
    left_motor_b.spin(FORWARD, drive_left, PERCENT)
    right_motor_a.spin(FORWARD, drive_right, PERCENT)
    right_motor_b.spin(FORWARD, drive_right, PERCENT)

    # and all the auxilary motors
    # motor_3.spin(FORWARD, drive_m_3, PERCENT)
    # motor_4.spin(FORWARD, drive_m_4, PERCENT)
    # motor_5.spin(FORWARD, drive_m_5, PERCENT)
    # motor_6.spin(FORWARD, drive_m_6, PERCENT)
    # motor_7.spin(FORWARD, drive_m_7, PERCENT)
    # motor_8.spin(FORWARD, drive_m_8, PERCENT)

    # Max motor speed (percent) for motors controlled by buttons
    MAX_SPEED = 80

    #-----------------------------------------------------------------------------*/
    #   @brief  Drive task                                                        */
    #-----------------------------------------------------------------------------*/
    #
    # All motors are controlled from this function which is run as a separate thread
    #

    drive_left_cur = 0
    drive_right_cur = 0

    brainPrevStepTime = int(brain.timer.time(MSEC))
    betweenStepTime = 0
    #This sets the motors velocity, torque and it makes the motors stop at first
    arm_motor_group_control_motors_stopped = True
    arm_motor_a_control_motors_stopped = True
    arm_motor_b_control_motors_stopped = True
    arm_motor_group.set_stopping(HOLD)
    arm_motor_group.set_max_torque(100, PERCENT)
    arm_motor_b.set_max_torque(100, PERCENT)
    arm_motor_b.set_velocity(100,PERCENT)

    arm_motor_a.set_stopping(HOLD)

    while True:
        #This is where the user controls are turned into the Robot movements
        #From the class above whichever one is picked thats how it would work
        if(not auton):
            if drive_mode == DriveType.LEFT:
                drive_left = int(controller_1.axis3.position()) + int(controller_1.axis4.position())
                drive_right = int(controller_1.axis3.position()) - int(controller_1.axis4.position())
            elif drive_mode == DriveType.DUAL:
                drive_left = controller_1.axis3.position()
                drive_right = controller_1.axis2.position()
            elif drive_mode == DriveType.SPLIT:
                drive_left = controller_1.axis3.position() + controller_1.axis1.position()
                drive_right = controller_1.axis3.position() - controller_1.axis1.position()
            elif drive_mode == DriveType.RIGHT:
                drive_left = controller_1.axis2.position() + controller_1.axis1.position()
                drive_right = controller_1.axis2.position() - controller_1.axis1.position()

            ## Deadband allows non 0 ret to not move robbot
            # This is to avoid stickdrift
            deadband = 5
            if abs(drive_left) < deadband:
                drive_left = 0
            if abs(drive_right) < deadband:
                drive_right = 0
            
            ## Start arm control
            ## This is the controls for the arm

            ## arm control base
            if controller_1.buttonR1.pressing():
                arm_motor_group.spin(FORWARD)
                arm_motor_group_control_motors_stopped = False
            elif controller_1.buttonR2.pressing():
                arm_motor_group.spin(REVERSE)
                arm_motor_group_control_motors_stopped = False
            ###end control when not in use
            elif not arm_motor_group_control_motors_stopped:
                arm_motor_group.stop()
                # set the toggle so that we don't constantly tell the motor to stop when
                # the buttons are released
                arm_motor_group_motors_stopped = True

            ##arm control first joint
            elif controller_1.buttonL1.pressing():    
                arm_motor_a.spin(FORWARD)
                arm_motor_a_control_motors_stopped = False
            elif controller_1.buttonL2.pressing():
                arm_motor_a.spin(REVERSE)
                arm_motor_a_control_motors_stopped = False
            ###end when not in use
            elif (not arm_motor_a_control_motors_stopped):
                arm_motor_a.stop()
                # set the toggle so that we don't constantly tell the motor to stop when
                # the buttons are released
                arm_motor_a_motors_stopped = True

            ##arm control belt
            if controller_1.buttonUp.pressing():
                arm_motor_b.spin(FORWARD)
                arm_motor_b_control_motors_stopped = False
            elif controller_1.buttonDown.pressing():
                arm_motor_b.spin(REVERSE)
                arm_motor_b_control_motors_stopped = False
            ###end when not in use
            elif not arm_motor_b_control_motors_stopped:
                arm_motor_b.stop()
                # set the toggle so that we don't constantly tell the motor to stop when
                # the buttons are released
                arm_motor_b_motors_stopped = True

            ## End arm control 

            if(recordInput and (drive_left != drive_left_cur or drive_right != drive_right_cur)):
                drive_left_cur = drive_left
                drive_right_cur = drive_right


                ####Auton
                ##time setup
                betweenStepTime = int(brain.timer.time(MSEC)) - brainPrevStepTime
                brainPrevStepTime = int(brain.timer.time(MSEC))

                ##printing
                # driveWord = drive_left + ":" + drive_right
                print(drive_left, drive_right, end=":", sep=":")
                print(betweenStepTime)


                #drive - drive_left, drive_right
                motor_task(drive_left, drive_right)
            
            if(recordInput and (arm_control_group_cur != arm_motor_group_motors_stopped or arm_control_1_cur != arm_motor_a_control_motors_stopped or arm_control_2_cur != arm_motor_b_control_motors_stopped)):
                arm_control_group_cur = arm_motor_group_motors_stopped
                arm_control_1_cur = arm_motor_a_control_motors_stopped
                arm_control_2_cur = arm_motor_b_control_motors_stopped

                ####Auton
                ##time setup
                betweenStepTime = int(brain.timer.time(MSEC)) - brainPrevStepTime
                brainPrevStepTime = int(brain.timer.time(MSEC))
                print(arm_control_group_cur, arm_control_1_cur, arm_control_2_cur, end=":", sep=":")
                print(betweenStepTime)

                
            
        else:
            drive_inputSplit = DRIVE_RECORDED_INPUT.split(":")
            arm_inputSplit = ARM_RECORDED_INPUT.split(":")
            print("Drive: ", len(drive_inputSplit))
            print("Arm: ", len(arm_inputSplit))


            for num in range(int(len(drive_inputSplit)//3)):
                print("num:",num)

                d_left = drive_inputSplit[3*num]
                print(d_left)
                d_right = drive_inputSplit[3*num + 1]
                print(d_right)
                wait_time = int(drive_inputSplit[3*num + 2])
                print(wait_time)

                wait(wait_time, MSEC)

            for num in range(int(len(arm_inputSplit)//4)):
                print("num:",num)

                arm_group = arm_inputSplit[3*num]
                print(arm_group)
                arm_a = arm_inputSplit[3*num + 1]
                print(arm_a)
                arm_b = arm_inputSplit[3*num + 2]
                print(arm_b)
                wait_time = int(arm_inputSplit[3*num + 3])
                print(wait_time)

                wait(wait_time, MSEC)

    
# This is our attempt at Autonomous it does not work yet 
def autonomous():
        '''inputSplit = RECORDED_INPUT.split(":")
        for num in range(int(len(inputSplit)//3)):
            d_left = inputSplit[3*num]
            d_right = inputSplit[3*num + 1]
            wait_time = inputSplit[3*num + 2]
            motor_task(d_left, d_right)            
            wait(wait_time, MSEC)
            '''
        left_motor_a.spin(FORWARD)
# This is everything I explained in the while loop but now in a function
def driver_control():
    arm_motor_group_control_motors_stopped = True
    arm_motor_a_control_motors_stopped = True
    arm_motor_b_control_motors_stopped = True
    arm_motor_group.set_stopping(HOLD)
    arm_motor_group.set_max_torque(100, PERCENT)
    arm_motor_a.set_stopping(HOLD)

    if drive_mode == DriveType.LEFT:
        drive_left = int(controller_1.axis3.position()) + int(controller_1.axis4.position())
        drive_right = int(controller_1.axis3.position()) - int(controller_1.axis4.position())
    elif drive_mode == DriveType.DUAL:
        drive_left = controller_1.axis3.position()
        drive_right = controller_1.axis2.position()
    elif drive_mode == DriveType.SPLIT:
        drive_left = controller_1.axis3.position() + controller_1.axis1.position()
        drive_right = controller_1.axis3.position() - controller_1.axis1.position()
    elif drive_mode == DriveType.RIGHT:
        drive_left = controller_1.axis2.position() + controller_1.axis1.position()
        drive_right = controller_1.axis2.position() - controller_1.axis1.position()

    ## Deadband allows non 0 ret to not move robbot
    deadband = 5
    if abs(drive_left) < deadband:
        drive_left = 0
    if abs(drive_right) < deadband:
        drive_right = 0
        
        ## Start arm control

        if controller_1.buttonR1.pressing():
            arm_motor_group.spin(FORWARD)
            arm_motor_group_control_motors_stopped = False
        elif controller_1.buttonR2.pressing():
            arm_motor_group.spin(REVERSE)
            arm_motor_group_control_motors_stopped = False
        elif not arm_motor_group_control_motors_stopped:
            arm_motor_group.stop()
            # set the toggle so that we don't constantly tell the motor to stop when
            # the buttons are released
            arm_motor_group_motors_stopped = True

        if controller_1.buttonL1.pressing():
            arm_motor_a.spin(FORWARD)
            arm_motor_a_control_motors_stopped = False
        elif controller_1.buttonL2.pressing():
            arm_motor_a.spin(REVERSE)
            arm_motor_a_control_motors_stopped = False
        elif not arm_motor_a_control_motors_stopped:
            arm_motor_a.stop()
            # set the toggle so that we don't constantly tell the motor to stop when
            # the buttons are released
            arm_motor_a_motors_stopped = True

        if controller_1.buttonUp.pressing():
            arm_motor_b.spin(FORWARD)
            arm_motor_b_control_motors_stopped = False
        elif controller_1.buttonDown.pressing():
            arm_motor_b.spin(REVERSE)
            arm_motor_b_control_motors_stopped = False
        elif not arm_motor_b_control_motors_stopped:
            arm_motor_b.stop()
            # set the toggle so that we don't constantly tell the motor to stop when
            # the buttons are released
            arm_motor_b_motors_stopped = True


##Stuff that does stuff
# Run the drive code
drive = Thread(motor_task)

#Does something
competition = Competition(driver_control, autonomous)
