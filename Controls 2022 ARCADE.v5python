{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nmotor1L = Motor(Ports.PORT1, GearSetting.RATIO_6_1, False)\nmotor2L = Motor(Ports.PORT2, GearSetting.RATIO_6_1, True)\ncatapult1 = Motor(Ports.PORT7, GearSetting.RATIO_6_1, True)\nmotor1R = Motor(Ports.PORT3, GearSetting.RATIO_6_1, True)\nmotor2R = Motor(Ports.PORT4, GearSetting.RATIO_6_1, False)\ncatapult2 = Motor(Ports.PORT8, GearSetting.RATIO_6_1, False)\nintake = Motor(Ports.PORT5, GearSetting.RATIO_6_1, False)\nendgame = Motor(Ports.PORT6, GearSetting.RATIO_6_1, False)\ncontroller_1 = Controller(PRIMARY)\nsol_a = DigitalOut(brain.three_wire_port.g)\nsol_b = DigitalOut(brain.three_wire_port.h)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n#endregion VEXcode Generated Robot Configuration\n\n# ------------------------------------------\n# \n# \tProject:      Control and Record 2022\n#\tAuthor:       Gavin Sanders\n#\tCreated:      October 2022\n#\tDescription:  Stores and replays controller input\n# \n# ------------------------------------------\n\n# Library imports\nfrom vex import *\n\n# Begin project code\n\n#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n#endregion VEXcode Generated Robot Configuration\n\n# Library imports\nfrom vex import *\n\n# Begin project code\n\nleftMotors = (motor1L, motor2L)\nrightMotors = (motor1R, motor2R)\n\nleftSpeed, rightSpeed = 1, 1\nprevLeftState, prevRightState = None, None\nlHorizAxisState, rHorizAxisState = 1, 1\nprevLHorizAxisState, PrevRHorizAxisState = None, None\n\nbutton_states = [False for i in range(12)]\nprev_button_states = [False for i in range(12)]\n\nrecordInput = False\n\nautonomous_start_offset = 0\nfirst_record = True\n\n#Paste recorded input here:\nRECORDED_INPUT = \"0&1&0&1&000000001000@0|0&1&0&1&000000000000@1417|\"\n##############\n\ncatapult1.set_stopping(HOLD)\ncatapult2.set_stopping(HOLD)\n\ndef move(l, a2, a4, r):\n    global button_states\n\n    invert = 1\n    if(button_states[6]):\n        invert = -1\n\n\n    if(l > 0):\n        leftside = l * invert\n        rightside = l * invert\n\n        if(r != 0):\n            leftside = l * invert + (r // 2) \n            rightside = l * invert - (r // 2) \n\n\n        for motor in leftMotors:\n            motor.spin(FORWARD)\n            motor.set_velocity(leftside, PERCENT)  \n\n        for motor in rightMotors:\n            motor.spin(FORWARD)\n            motor.set_velocity(rightside, PERCENT)  \n        \n    elif(l < 0):\n        leftside = l * invert\n        rightside = l * invert\n\n        if(r != 0):\n            leftside = l * invert + (r // 2) \n            rightside = l * invert - (r // 2) \n\n        for motor in leftMotors:\n            motor.spin(REVERSE)\n            motor.set_velocity(leftside, PERCENT)  \n\n        for motor in rightMotors:\n            motor.spin(REVERSE)\n            motor.set_velocity(rightside, PERCENT)  \n\n    else:\n        if(r > 0):\n            leftside = r // 2 \n            rightside = -r // 2\n\n            for motor in leftMotors:\n                motor.spin(FORWARD)\n                motor.set_velocity(leftside, PERCENT)  \n\n            for motor in rightMotors:\n                motor.spin(REVERSE)\n                motor.set_velocity(rightside, PERCENT) \n\n        elif(r < 0):\n            leftside = r // 2 \n            rightside = -r // 2\n\n            for motor in leftMotors:\n                motor.spin(REVERSE)\n                motor.set_velocity(leftside, PERCENT)  \n\n            for motor in rightMotors:\n                motor.spin(FORWARD)\n                motor.set_velocity(rightside, PERCENT)  \n        \n        \n        else:\n            for motor in leftMotors:\n                motor.stop()\n            for motor in rightMotors:\n                motor.stop()\n\n    \n    \n    #THIS IS REALLY IMPORTANT TO KNOW\n    #button order: l1[0], l2[1], r1[2], r2[3], up[4], right[5], down[6], left[7], x[8], a[9], b[10], y[11]\n\n    #EXAMPLE OF HOW TO SET BUTTON TO MOTOR:\n    if(button_states[8]):\n        # SET TO X BUTTON\n        intake.spin(FORWARD)\n        intake.set_velocity(100, PERCENT)\n    else:\n        intake.stop()\n\n    # if(button_states[9] == True):\n    #     # Set to A\n    #     roller.spin(FORWARD)\n    #     roller.set_velocity(80, PERCENT)\n    # else:\n    #     roller.stop()\n    \n    # if(button_states[10] == True):\n    #     # Set to B\n    #     flywheel.spin(FORWARD)\n    #     flywheel.set_velocity(100, PERCENT)\n    # else:\n    #     flywheel.stop()\n\n    if(button_states[11] == True):\n        # Set to Y\n        catapult1.spin(FORWARD)\n        catapult2.spin(FORWARD)\n        catapult1.set_velocity(30, PERCENT)\n        catapult2.set_velocity(30, PERCENT)\n    else:\n        catapult1.stop()\n        catapult2.stop()\n\n    \n    if(button_states[0] == True):\n        endgame.spin(REVERSE)\n        endgame.set_velocity(100, PERCENT)\n    elif(button_states[1] == True):\n        endgame.spin(FORWARD)\n        endgame.set_velocity(-100, PERCENT)\n    else:\n        endgame.stop()\n        \n\n    # if(button_states[4] == True):\n    #     #### AIMBOT ####\n    #     linedup = False\n    #     centerFOV = 316 / 2\n    #     amount = 10\n    #     VisionSensor__NETR = None\n    #     t = brain.timer.time(SECONDS)\n    #     while((not linedup) and (brain.timer.time(SECONDS) - t <= 4)):  \n    #         offsetX = 10\n    #         amount = 10 \n    #         box = VisionSensor.take_snapshot(VisionSensor__NETR)\n    #         #box = VisionSensor.take_snapshot(VisionSensor__NETB)\n\n    #         if(box is not None):\n    #             cx = VisionSensor.largest_object().centerX\n    #             if(cx > centerFOV + offsetX):\n    #                 #turn left\n    #                 motorTL.spin(REVERSE)\n    #                 motorTL.set_velocity(amount, PERCENT)\n    #                 motorTR.spin(FORWARD)\n    #                 motorTR.set_velocity(-1 * amount, PERCENT)\n    #                 motorBL.spin(REVERSE)\n    #                 motorBL.set_velocity(amount, PERCENT)\n    #                 motorBR.spin(FORWARD)\n    #                 motorBR.set_velocity(-1 * amount, PERCENT)\n\n    #             elif(cx < centerFOV - offsetX):\n    #                 #turn right\n    #                 motorTL.spin(FORWARD)\n    #                 motorTL.set_velocity(amount, PERCENT)\n    #                 motorTR.spin(REVERSE)\n    #                 motorTR.set_velocity(-1 * amount, PERCENT)\n    #                 motorBL.spin(FORWARD)\n    #                 motorBL.set_velocity(amount, PERCENT)\n    #                 motorBR.spin(REVERSE)\n    #                 motorBR.set_velocity(-1 * amount, PERCENT)\n                    \n    #             else:\n    #                 linedup = True\n            \n    #         wait(20, MSEC)\n        \n    \n    # EXAMPLE OF HOW TO SET BUTTON TO SOLENOID\n    sol_a.set(not button_states[8])\n    sol_b.set(not button_states[9])\n\n#CHANGE FOR OTHER AXES\ndef somethingChanged():\n    if(leftSpeed != prevLeftState or rightSpeed != prevRightState or button_states != prev_button_states):\n        return True\n    return False\n\ndef record():\n    global first_record\n    global autonomous_start_offset\n    if(first_record):\n        autonomous_start_offset = int(brain.timer.time(MSEC))\n        first_record = not first_record\n    print(str(leftSpeed) + \"&\" + str(lHorizAxisState) + \"&\" + str(rightSpeed) + \"&\" + str(rHorizAxisState)  + \"&\" + str(int(button_states[0])) + str(int(button_states[1])) + str(int(button_states[2])) + str(int(button_states[3])) + str(int(button_states[4]))\n    + str(int(button_states[5])) + str(int(button_states[6])) + str(int(button_states[7])) + str(int(button_states[8])) + str(int(button_states[9])) + str(int(button_states[10])) + str(int(button_states[11])) + \"@\" + str(int(brain.timer.time(MSEC)) - autonomous_start_offset) + \"|\", end=\"\")\n\n#######################################\ndef pre_autonomous():\n    # actions to do when the program starts\n    wait(1, SECONDS)\n#########################################\ndef autonomous():\n    global button_states\n\n    for i in range(len(button_states)):\n        button_states[i] = False\n\n    startIndex = 0\n    startTime = int(brain.timer.time(MSEC))\n\n    while(startIndex < len(RECORDED_INPUT)):\n        chunk = RECORDED_INPUT[startIndex : RECORDED_INPUT.index(\"|\", startIndex)]\n        #LEFT VERTICAL AXIS\n        andIndex1 = chunk.index(\"&\")\n        a3 = int(chunk[0 : andIndex1])\n\n        andIndex2 = chunk.index(\"&\", andIndex1 + 1)\n        a4 = int(chunk[andIndex1 + 1 : andIndex2])\n\n        #RIGHT VERTICAL AXIS\n        andIndex3 = chunk.index(\"&\", andIndex2 + 1)\n        a2 =int(chunk[andIndex2 + 1 : andIndex3])\n        rightaxis = a2\n\n        andIndex4 = chunk.index(\"&\", andIndex3 + 1)\n        a1 = int(chunk[andIndex3 + 1 : andIndex4])\n\n        l1 = chunk[andIndex4 + 1 : andIndex4 + 2]\n        l2 = chunk[andIndex4 + 2 : andIndex4 + 3]\n        r1 = chunk[andIndex4 + 3 : andIndex4 + 4]\n        r2 = chunk[andIndex4 + 4 : andIndex4 + 5]\n        up = chunk[andIndex4 + 5 : andIndex4 + 6]\n        right = chunk[andIndex4 + 6 : andIndex4 + 7]\n        down = chunk[andIndex4 + 7 : andIndex4 + 8]\n        left = chunk[andIndex4 + 8 : andIndex4 + 9]\n        X = chunk[andIndex4 + 9 : andIndex4 + 10]\n        A = chunk[andIndex4 + 10 : andIndex4 + 11]\n        B = chunk[andIndex4 + 11 : andIndex4 + 12]\n        Y = chunk[andIndex4 + 12 : andIndex4 + 13]\n\n        buttons = [l1, l2, r1, r2, up, right, down, left, X, A, B, Y]\n        \n        atIndex = chunk.index(\"@\")\n        milliseconds = int(chunk[(atIndex + 1) : len(chunk)])\n        \n        startIndex += (len(chunk) + 1)\n\n        while(True):\n            if(milliseconds <= int(brain.timer.time(MSEC) - startTime)):\n                for i in range(len(buttons)):\n                    button_states[i] = bool(int(buttons[i]))\n\n                move(a3, a2, a4, a1)\n                #print(\"L: \" + str(a3) + \" R: \" + str(a2))\n                break\n            \n\n\n##########################################   \n\ndef user_control():\n    global leftSpeed\n    global rightSpeed\n    global recordInput\n    global prevLeftState\n    global prevRightState\n    global prev_button_states\n    global button_states\n\n    #button order: l1[0], l2[1], r1[2], r2[3], up[4], right[5], down[6], left[7], x[8], a[9], b[10], y[11]\n    while(True):   \n        leftSpeed = controller_1.axis3.position()\n        rightSpeed = controller_1.axis2.position()\n        other1 = controller_1.axis4.position()\n        other2 = controller_1.axis1.position()\n        \n        if(controller_1.buttonUp.pressing()):\n            recordInput = not(recordInput)\n            \n            if(recordInput):\n                controller_1.screen.print(\"RECORDING\")\n            else:\n                controller_1.screen.clear_screen()\n            \n            wait(200, MSEC)\n\n        # if(controller_1.buttonY.pressing()):\n        #     button_states[11] = not button_states[11]\n            \n            wait(200, MSEC)\n        if(controller_1.buttonX.pressing()):\n            button_states[8] = not button_states[8]\n            wait(200, MSEC)\n        \n        if(controller_1.buttonDown.pressing()):\n            button_states[6] = not button_states[6]\n            wait(200, MSEC)\n\n        if(controller_1.buttonA.pressing()):\n            button_states[9] = not button_states[9]\n            wait(200, MSEC)\n\n        if(controller_1.buttonB.pressing()):\n            button_states[10] = not button_states[10]\n            wait(200, MSEC)\n            \n\n        # MOVE MOTOR WITH SHOULDER BUTTONS\n        if(controller_1.buttonY.pressing()):\n            button_states[11] = True\n        else:\n            button_states[11] = False\n        \n        if(controller_1.buttonL1.pressing()):\n            button_states[0] = True\n        else:\n            button_states[0] = False\n        \n        if(controller_1.buttonL2.pressing()):\n            button_states[1] = True\n        else:\n            button_states[1] = False\n        \n\n        if(controller_1.buttonR1.pressing()):\n            button_states[2] = True\n        else:\n            button_states[2] = False\n        \n        if(controller_1.buttonR2.pressing()):\n            button_states[3] = True\n        else:\n            button_states[3] = False\n\n\n\n        move(leftSpeed, rightSpeed, other1, other2)\n\n        if(somethingChanged()):\n            prevLeftState = leftSpeed\n            prevRightState = rightSpeed\n            prev_button_states = button_states.copy()\n            \n            if(recordInput):\n                record()\n\n        wait(20, MSEC)\n\n#########################################\n\n# create competition instance\ncomp = Competition(user_control, autonomous)\n\n###DELETE THIS FOR COMPETITION###\n# autonomous()\n#################################\n","textLanguage":"python","rconfig":[{"port":[1],"name":"motor1L","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[2],"name":"motor2L","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[7],"name":"catapult1","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[3],"name":"motor1R","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[4],"name":"motor2R","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[8],"name":"catapult2","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[5],"name":"intake","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[6],"name":"endgame","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[7],"name":"sol_a","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22},{"port":[8],"name":"sol_b","customName":true,"deviceType":"DigitalOut","deviceClass":"digital_out","setting":{"id":"partner"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"2.4.0","minVersion":"2.4.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","target":"Physical"}